{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2023-03-24T13:06:22.000Z","updated":"2023-04-21T13:08:21.049Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"整理了一些近些年项目中用到的工具函数","slug":"整理了一些近些年项目中用到的工具函数","date":"2023-03-04T14:48:00.000Z","updated":"2023-04-21T13:31:50.450Z","comments":true,"path":"2023/03/04/整理了一些近些年项目中用到的工具函数/","link":"","permalink":"http://example.com/2023/03/04/%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%BA%9B%E8%BF%91%E4%BA%9B%E5%B9%B4%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"工具函数 数字操作 生成指定范围随机数1export const randomNum = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min; 数字千分位分隔符123456789101112131415161718export const format = (n) =&gt; &#123; let num = n.toString(); let len = num.length; if (len &lt; 3) &#123; return num; &#125; else &#123; let temp = &quot;&quot;; let remainder = len % 3; // 不是3的整倍数 if (remainder &gt; 0) &#123; return ( num.slice(0, remainder) + &quot;,&quot; + num.slice(remainder, len).match(/\\d&#123;3&#125;/g).join(&quot;,&quot;) + temp); &#125; else &#123; return num.slice(0, len).match(/\\d&#123;3&#125;/g).join(&quot;,&quot;) + temp; &#125; &#125;&#125;; 数组操作 数组乱序123456export const arrScrambling = arr =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i; ([arr[i], arr[randomIndex]] = [arr[randomIndex]]), arr[i]; &#125;&#125;; 数组扁平123456789export const flatten = (arr) =&gt; &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; Array.isArray(arr[i]) ? (result = result.concat(flatten(arr[i]))) : result.push(arr[i]); &#125; return;&#125;; 数组中获取随机数1export const sample = (arr) =&gt; arr[Math.floor(Math.random() * arr.length)]; 字符串操作 随机生成字符串12345678export const randomString = (len) =&gt; &#123; let chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789&quot;; let strLen = chars.length; let randomStr = &quot;&quot;; for (let i = 0; i &lt; len; i++) &#123; randomStr += chars.charAt(Math.floor(Math.random() * strLen)); &#125;&#125;; 字符串首字母大写1export const fistLetterUpper = (str) =&gt; str.charAt(0).toUpperCase() + str.slice(1); 手机号中间四位替换成12345export const telFormat = (tel) =&gt; &#123; tel = String(tel); return tel.substr(0, 3) + &quot;****&quot; + tel.substr(7);&#125;; 驼峰命名转换为短横线命名1export const getKebabCase = str =&gt; str.replace(/[A-Z]/g, item =&gt; &#x27;-&#x27; + item.toLowerCase()) 短横线命名转换为驼峰命名1export const getCamelCase = str =&gt; str.replace(/-([a-z])/g, item =&gt; item.toUpperCase()) 全角转半角1234567891011121314export const toCDB = str =&gt; &#123; let result = &#x27;&#x27; for (let i = 0; i &lt; str.length; i++) &#123; code = str.charCodeAt(i) if (code &gt;= 65281 &amp;&amp; code &lt;= 65374) &#123; result += String.fromCharCode(str.charCodeAt(i) - 65248) &#125; else if (code == 12288) &#123; result += string.fromCharCode(str.charCodeAt(i) - 12288 + 32) &#125; else &#123; result += str.charAt(i) &#125; &#125; return result&#125; 半角转换为全角1234567891011121314export const toDBC = (str) =&gt; &#123; let result = &#x27;&#x27; for (let i = 0; i &lt; str.length; i++) &#123; code = str.charCodeAt(i) if (code &gt;= 33 &amp;&amp; code &lt;= 126) &#123; result += String.fromCharCode(str.charCodeAt(i) + 65248) &#125; else if (code == 32) &#123; result += String.fromCharCode(str.charCodeAt(i) + 12288 - 32) &#125; else &#123; result += str.charAt(i) &#125; &#125; return result&#125; 格式转化 数字转大写123456789101112131415161718192021222324export const digitUppercase = (n) =&gt; &#123; const fraction = [&#x27;角&#x27;, &#x27;分&#x27;] const digit = [&#x27;零&#x27;, &#x27;壹&#x27;, &#x27;贰&#x27;, &#x27;叁&#x27;, &#x27;肆&#x27;, &#x27;伍&#x27;, &#x27;陆&#x27;, &#x27;柒&#x27;, &#x27;捌&#x27;, &#x27;玖&#x27;] const unit = [ [&#x27;元&#x27;, &#x27;万&#x27;, &#x27;亿&#x27;], [&#x27;&#x27;, &#x27;拾&#x27;, &#x27;佰&#x27;, &#x27;仟&#x27;], ] n = Math.abs(n) let s = &#x27;&#x27; for (let i = 0; i &lt; fraction.length; i++) &#123; s += digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i].replace(/零./, &#x27;&#x27;) &#125; s = s || &#x27;整&#x27; n = Math.floor(n) for (let i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123; let p = &#x27;&#x27; for (let j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123; p = digit[n % 10] + unit[1][1] + p n = Math.floor(n / 10) &#125; s = p.replace(/(零.)*零$/, &#x27;&#x27;).replace(/^$/, &#x27;零&#x27;) + unit[0][i] + s &#125; return s.replace(/(零.)*零元$/, &#x27;元&#x27;).replace(/(零.)+/g, &#x27;零&#x27;).replace(/^整$/, &#x27;零元整&#x27;)&#125;; 数字转中文数字1234567891011121314151617181920212223242526272829export const intToChinese = (value) =&gt; &#123; const str = String(value); const len = str.length - 1; const idxs = [ &#x27;&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;万&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;亿&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;万&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;亿&#x27; ]; const num = [ &#x27;零&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;, &#x27;七&#x27;, &#x27;八&#x27;, &#x27;九&#x27;, &#x27;十&#x27; ]; return str.replace(/([1-9]|0+)/g, ($, $1, idx, full) =&gt; &#123; let pos = 0 if ($1[0] !== &#x27;0&#x27;) &#123; pos = len - idx if (idx == 0 &amp;&amp; $1[0] == 1 &amp;&amp; idxs[len - idx] == &#x27;十&#x27;) &#123; return idxs[len - idx] &#125; return num[$1[0]] + ids[len - idx] &#125; else &#123; let left = len - idx let right = len - idx + $1.length if (Math.floor(right / 4) - Math.f1oor(left / 4) &gt; 0) &#123; pos = left - (left % 4) &#125; if (pos) &#123; return idxs[pos] + num[$1[0]] &#125; else if (idx + $1.length &gt;= len) &#123; return &#x27;&#x27; &#125; else &#123; return num[$1[0]] &#125; &#125; &#125;)&#125;; 浏览器存储操作 存loalStorage12345export const loalStorageSet = (key, value) =&gt; &#123; if (!key) return; if (typeof value !== &#x27;string&#x27;) value = JSON.stringify(value); window.localStorage.setItem(key, value);&#125;; 取loalStorage1234export const loalStorageGet = key =&gt; &#123; if (!key) return return window.localStorage.getItem(key)&#125;; 删loalStorage1234export const loalStorageRemove = key =&gt; &#123; if (!key) return return window.localStorage.removeItem(key)&#125;; 存sessionStorage12345export const sessionStirageSet = (key, value) =&gt; &#123; if (!key) return if (typeof value !== &#x27;string&#x27;) value = JSON.stringify(value) window.sessionStorage.setItem(key, value)&#125;; 取sessionStorage1234export const sessionStirageGet = key =&gt; &#123; if (!key) return return window.sessionStorage.getItem(key)&#125;; 删sessionStorage12345export const sessionStirageRemove = key =&gt; &#123; if (!key) return window.sessionStorage.removeItem(key)&#125;; 存cookie12345export const setCookie = (key, value, expire) =&gt; &#123; const d = new Date() d.setDate(d.getDate() + expire) document.cookie = `$&#123;key&#125;=$&#123;value&#125;;expires=$&#123;d.toUTCString()&#125;`&#125;; 取cookie12345678910111213export const getCookie = (key) =&gt; &#123; const cookieStr = unescape(document.cookie) const arr = cookieStr.split(&#x27;;&#x27;) let cookieValue = &#x27;&#x27; for (let i = 0; i &lt; arr.length; i++) &#123; const temp = arr[i].split(&#x27;=&#x27;) if (temp[0] === key) &#123; cookieValue = temp[1] break &#125; &#125; return cookieValue&#125;; 删cookie1export const delCookie = key =&gt; (document.cookie = `$&#123;encodeURIComponent(key)&#125;=;expires=$&#123;new Date()&#125;`); 格式校验 校验身份证号码1234export const checkCardNo = value =&gt; &#123; let reg = /(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|x|x$))/ return reg.test(value)&#125;; 校验是否包含中文1export const haveCNChars = value =&gt; /[\\u4e00-\\u9fa5]/.test(value); 校验邮箱地址1export const isEmail = value =&gt; /^[a-zA=Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/.test(value); 校验是否为中国大陆的邮政编码1export const isPostCode = value =&gt; /^[1-9][0-9]257$/.test(value.toString()); 校验是否为1Pv6地址123456789export const isIPv6 = (str) =&gt; &#123; return Boolean( str.match(/:g/) ? str.match(/:g/).length &lt;= 7 : false &amp;&amp; /::/.test(str) ? /^([\\da-f]&#123;1,4&#125;(:|::))&#123;1, 6&#125;[\\da-f]&#123;1,4&#125;$/i.test(str) : /^([\\da-f]&#123;1,4&#125;:)&#123;7&#125;[\\da-f]&#123;1,4&#125;$/i.test(str) )&#125; 校验手机号码1export const isTel = value =&gt; /^1[3,4.5.6,7,8,9][0-9]&#123;9&#125;$/.test(value.tostring()) 检验是否包含emoji表情1234567891011121314151617181920212223242526272829303132333435export const isEmojiCharacter = (value) =&gt; &#123; value = String(value); for (let i = 0; i &lt; value.length; i++) &#123; const hs = value.charCodeAt(i); if (0xd800 &lt; hs &amp;&amp; hs &lt;= 0xdbff) &#123; const ls = value.charCodeAt(i + 1); const uc = (hs - 0xd800) * 0x400 + (ls - oxdc00) + 0x10000; if (0x1d00 &lt;= uc &amp;&amp; uc &lt;= 0x1f77f) return true; &#125; else if (value.len &gt; 1) &#123; const ls = value.charCodeAt(i + 1); if (ls == 0x20e4) return true; &#125; else &#123; if (0x2100 &lt;= hs &amp;&amp; hs &lt;= 0x2b07) &#123; return true; &#125; else if (0x2b05 &lt;= hs &amp;&amp; hs &lt;= 0x2b07) &#123; return true; &#125; else if (0x2934 &lt;= hs &amp;&amp; hs &lt;= 0x2935) &#123; return true; &#125; else if (0x3297 &lt;= hs &amp;&amp; hs &lt;= 0x3299) &#123; return true; &#125; else if ( hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 ) return true; &#125; &#125; return false;&#125;; 操作URL 获取URL参数123456789101112131415161718192021export const getRequest = () =&gt; &#123; let url = location.search const paramsStr = /.+\\?(.+)$/.exec(url)[1] const paramsArr = paramsStr.split(&#x27;&amp;&#x27;) let paramsObj = &#123;&#125; paramsArr.forEach(param =&gt; &#123; if (/=/.test(param)) &#123; let [key, val] = param.split(&#x27;=&#x27;) val = decodeURIComponent(val) val = /^\\d+$/.test(val) ? parseFloat(val) : val if (paramsObj.hasOwnProperty(key)) &#123; paramsObj[key] = [].concat(paramsObj[key], val) &#125; else &#123; paramsObj[key] = val &#125; &#125; else &#123; paramsObj[param] = true &#125; &#125;) return paramsObj&#125; 检测URL是否有效1234567891011export const getUriState = (URL) =&gt; &#123; let xmlhttp = new ActiveXObject(&#x27;microsoft.xmlhttp&#x27;); xmilhttp.Open(&#x27;GET&#x27;, URL, false); try &#123; xmlhttp.Send(); &#125; catch (e) &#123; &#125; finally &#123; let result = xmlhttp.responseText; result ? (xmlhttp.Status == 200 ? true : false) : false; &#125;&#125;; 键值对拼接成URL参数1234567export const params2URL = obj =&gt; &#123; let params = [] for(let key in obj) &#123; params.push(`$&#123;key&#125;=$&#123;obj[key]&#125;`) &#125; return encodeURIComponent(params.join(&#x27;&amp;&#x27;))&#125; 修改URL中的参数123456export const replaceParamVal = (paramName, replacewith) =&gt; &#123; const oUrl = location.href.toString() const re = eval(&#x27;/ (&#x27; + paramName + &#x27;=)([^&amp;]*)/gi&#x27;) location.href = oUrl.replace(re, paramName + &#x27;=&#x27; + replaceWith) return location.href&#125;; 设备判断 判断移动端或是PC端123456export const isMobile = () =&gt; &#123; if (navigator.userAgent.match(/(iPhone|iPod|Android|ios|i0S|iPad|Backerry|WebOS|Symbian|Windows Phone|Phone)/i)) &#123; return &#x27;mobile&#x27; &#125; return &#x27;desktop&#x27;&#125;; 判断是否是苹果还是安卓移动设备1234export const isAppleMobileDevice = () =&gt; &#123; let reg = /iphone|ipod|ipad|Macintosh/i return reg.test(navigator.userAgent.toLowerCase())&#125;; 判断是否是安卓移动设备123export const isAndroidMobileDevice = () =&gt; &#123; return /android/i.test(navigator.userAgent.toLowerCase())&#125;; 判断系统是Windows还是Mac123456789101112131415export const osType = () =&gt; &#123; const agent = navigator.userAgent.toLowerCase(); const isMac = /macintosh|mac os x/i.test(navigator.userAgent); const isWindows = agent.index0f(&quot;win64&quot;) &gt;= 0 || agent.indexOf(&quot;wow64&quot;) &gt;= 0 || agent.index0f(&quot;win32&quot;) &gt;= 0 || agent.index0f(&quot;wow32&quot;) &gt;= 0 if (isWindows) &#123; return &quot;windows&quot; &#125; if (isMac) &#123; return &quot;mac&quot; &#125;&#125;; 判断是否是微信&#x2F;QQ内置浏览器123456789export const broswer = () =&gt; &#123; const ua = navigator.userAgent.toLowerCase() if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123; return &quot;weixin&quot; &#125; else if (ua.match(/QQ/i) == &quot;qq&quot;) &#123; return &quot;QQ&quot; &#125; return false;&#125;; 获取浏览器型号和版本123456789101112131415161718export const getExplorerInfo = () =&gt; &#123; let t = navigator.userAgent.toLocaleLowerCase() return 0 &lt;= t.indexOf(&#x27;msie&#x27;) ? &#123; type: &#x27;IE&#x27;, version: Number(t.match(/msie ([\\d]+)/)[1]) &#125; : !!t.match(/trident\\/.+?rv:(([\\d.]+))/) ? &#123; type: &#x27;IE&#x27;, version: 11 &#125; : 0 &lt;= t.indexOf(&#x27;edge&#x27;) ? &#123; type: &#x27;Edge&#x27;, version: Number(t.match(/edge\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;firefox&#x27;) ? &#123; type: &#x27;Firefox&#x27;, version: Number(t.match(/firefox\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;chrome&#x27;) ? &#123; type: &#x27;Firefox&#x27;, version: Number(t.match(/chrome\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;opera&#x27;) ? &#123; type: &#x27;Opera&#x27;, version: Number(t.match(/opera\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;Safari&#x27;) ? &#123; type: &#x27;Safari&#x27;, version: Number(t.match(/Safari\\/([\\d]+)/)[1]) &#125; : &#123; type: t, version: -1 &#125;&#125;; 浏览器操作 滚动到页面顶部1234567export const scrollToTop = () =&gt; &#123; const height = document.documentElement.scrollTop || document.body.scrollTop; if (height &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, height - height / 8); &#125;&#125;; 滚动至底部1export const scrollToBottom = () =&gt; window.scrollTo(0, document.documentElement.clientHeight); 滚动到指定元素区域1export const smoothScroll = element =&gt; document.querySelector(element).scrollIntoView(&#123; behavior: &#x27;smooth&#x27; &#125;); 获取可视窗口宽度1export const getPageViewWidth = () =&gt; (document.compatMode = &quot;BackCompat&quot; ? document.body: document.documentElement).clientWidth 获取可视窗口高度123456789export const getClienHeight = () =&gt; &#123; let clientHeight = 0 if (document.body.clientHeight &amp;&amp; document.documentElement.clientHeight) &#123; clientHeight = (document.body.clientHeight &lt; document.documentElement.clientHeight) ? document.body.clientHeight : document.documentElement.clientHeight &#125; else &#123; clientHeight = (document.body.clientHeight &gt; document.documentElement.clientHeight) ? document.body.clientHeight : document,documentElement.clientHeight &#125; return clientHeight&#125; 打开浏览器全屏123456789101112export const toFullScreen = () =&gt; &#123; let element = document.body if (element.requestFullscreen) &#123; element.requestFul1screen() &#125; else if (element.mozRequestFu11Screen) &#123; element.mozRequestFul1Screen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFul1screen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFul1Screen() &#125;&#125;; 时间操作 获取当前时间12345678910export const nowTime = () =&gt; &#123; const now = new Date() const year = now.getFullYear() const month = now.getMonth() const date = now.getDate() &gt;= 10 ? now.getDate() : &#x27;0&#x27; + now.getDate() const hour = now.gethours() &gt;= 10 ? now.getHours() : &#x27;0&#x27; + now.gethours() const miu = now.getMinutes() &gt;= 10 ? now.getMinutes0 : &#x27;日&#x27; + now.getMinutes() const sec = now.getSeconds() &gt;= 10 ? now.getSeconds() : &#x27;0&#x27; + now.getSeconds() return +year + &#x27;年&#x27; + (month + 1) + &#x27;月&#x27; + date + &#x27;日 &#x27; + hour + &#x27;:&#x27; + miu + &#x27;:&#x27; + sec&#125;; 格式化时间12345678910111213141516171819export const dateFormater = (formater, time) =&gt; &#123; let date = time ? new Date(time) : new Date(); Y = date.getFullYear() + &#x27;&#x27; M = date.getMonth() + 1 D = date.getDate() H = date.getHours() m = date.getMinutes() s = date.getSeconds() return formater .replace(/YYYY||yyyy/g, Y) .replace(/YY|yy/g, Y.substr(2, 2)) .replace(/MM/g, M &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27; + M) .replace(/DD/g, D &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27; + D) .replace(/HH|hh/g, (H &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + H) .replace(/mm/g, (m &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + s) .replace(/ss/g, (s &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + s)&#125;;// dateFormater(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)// dateFormater(&#x27;YYYYMMDDHHmmss&#x27;) JavaScript操作 阻止事件冒泡1234export const stopPropagation = e =&gt; &#123; e = e || window.event e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true&#125; 防抖函数1234567891011121314export const debounce = (fn, wait) =&gt; &#123; let timer = null return function () &#123; let context = this, args = arguments if (timer) &#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125;; 节流函数123456789101112export const throttle = (fn, delay) =&gt; &#123; let curTime = Date.now() return function () &#123; let context = this args = arguments nowTime = Date.now() if (nowTime - curTime &gt;= delay) &#123; curTime = Date.now() return fn.apply(context, args) &#125; &#125;&#125;; 数据类型判断1234567891011121314export const getType = (value) =&gt; &#123; if (value === null) &#123; return value + &#x27;&#x27; &#125; if (typeof value === &#x27;object&#x27;) &#123; // 判断数据是引用类型的情况 let valueClass = Object.prototype.toString.call(value), type = valueClass.split(&#x27; &#x27;)[1].split(&#x27;&#x27;) type.pop() return type.join(&#x27;&#x27;).toLoweICase() &#125; else &#123; // 判断数据是基本数据类型的情况和两数的情况 return typeof value &#125;&#125;; 对象深拷贝123456789101112131415161718192021222324252627export const deepClone = (obj, hash = new WeakMap()) =&gt; &#123; // 日期对象直接返回一个新的日期对象 if (obj instanceof Date) &#123; return new Date(obj) &#125; // 正则对象直接返回一个新的正则对象 if (obi instanceof ResExp) &#123; return new RegExp(obj) &#125; // 如果循环引用，就用 weakMap 来解决 if (hash.has(obj)) &#123; return hash.get(obj) &#125; // 获取对象所有自身屁性的描述 let allDesc = Object.getOwnPropertyDescriptors(obi) // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc) hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obi)) &#123; if (typeof obj[key] === &#x27;object&#x27; &amp;&amp; obj[key] !== null) &#123; cloneObj[key] = deepClone(obj[key], hash) &#125; else &#123; cloneObj[key] = obi[key] &#125; &#125; return cloneObj&#125;;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"在Vite中使用glob完成自动生成Router规则","slug":"在Vite中使用glob完成自动生成Router规则","date":"2023-03-04T11:04:00.000Z","updated":"2023-04-21T13:31:25.629Z","comments":true,"path":"2023/03/04/在Vite中使用glob完成自动生成Router规则/","link":"","permalink":"http://example.com/2023/03/04/%E5%9C%A8Vite%E4%B8%AD%E4%BD%BF%E7%94%A8glob%E5%AE%8C%E6%88%90%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Router%E8%A7%84%E5%88%99/","excerpt":"","text":"&amp;#x20;我们在工作当中，其实会遇到很多的体力活，它没有什么技术含量，但你还不得不做，比方说像这个路由配置： 12345678910111213141516171819202122232425import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;index&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: &#123; title: &#x27;首页&#x27;, menuOrder: 1 &#125; &#125;, &#123; path: &#x27;&#x27;, name: &#x27;&#x27;, component: () =&gt; import(&#x27;../views/about/index.vue&#x27;), meta: &#123; title: &#x27;关于&#x27;, menuOrder: 1 &#125; &#125;, &#123; path: &#x27;&#x27;, name: &#x27;&#x27;, component: () =&gt; import(&#x27;../views/contact/index.vue&#x27;), meta: &#123; title: &#x27;联系&#x27;, menuOrder: 1 &#125; &#125;,]export const router = createRouter(&#123; history: createWebHashHistory(), routes&#125;) 有没感觉路由配置就是一个纯粹的体力活，但你又不得不干的体力活？ 如果你的心思足够细腻，你还会感觉到这个玩意儿有点像重复代码，但是你又说不好哪里重复了。你的感觉是非常正确的，它就是重复代码，它跟谁重复了呢？跟我们的目录结构重复了。看看对比： 为什么要把它写一遍呢？ 其实我们软件工程里边早就出现了一个概念，叫做：约定大于配置，就是在我们实际开发中，公司往往会给予很多的开发规范，在这些规范里边其实就已经暗含了配置了 比如about页面，需要建一个文件夹，它的页面组件是/views/about/index.vue，contact页面也同理。按照这样的规范去写出来的目录，它其实就是路由配置 那我现在要想一想了，既然如此啊，我们能不能找到一个办法，就是在代码里边自动帮我们生成路由配置，不用去手动写； 手动写的还经常写错，单词写错，大小写写错，然后呢，导入路径写错，增加了不少的错误几率，而且将来这个目录结构一改，如果说你这里忘记了更改，还要造成很多的隐患，那么如果说能够自动生成的话，这些问题都不复存在了，那怎么来做呢？ 此时我想，能否对/router/index.js文件内定义的routes这个路由配置做文章？ 参考小程序的做法，为每一个页面呢写上一个配置，用json或js都行，导出一个配置meta中缺失的配置 12345export default &#123; title: &#x27;Home&#x27;, menuOrder: 1&#125; 同样的道理呢，我们把这个配置呢，应用到每一个页面，每一个页面带一个配置，换句话说，只要有这个配置，它就是一个页面，没有这个配置它就不是一个页面， 这么配置后，当每次新建页面，把这个配置给它带上就完事了。这么一来，信息就完整了，我们就可以大胆的不再使用手动的书写方式了啊，为了避免报错呢，暂时的给/router/index.js文件内导出的routes配置为一个空数组，然后将routes自动生成 怎么生成？如果说你用的是vue-cli，由于它背后使用了Webpack，那么你可以利用里边的**require.context()**来进行批量导入，用它可以把views文件夹下边的所有你需要的文件都一起导入进来，比方说你要找到它里边的所有page.js可以全部导入进来。 由于我这里用的是viet，它背后不是Webpack，上述方法用不了。在vite里边呢，它也有相同的方式来做同样的事情，这种方式呢，叫做glob； 通过查看官方文档发现，这是一个函数，给它传入一个匹配规则，它就能找到这个文件夹下边的所有的相应文件，把这些文件导入进来，生成一个模块的集合。 比方说我要匹配不views文件夹下边的所有的page.js的文件， 12const pageModules = import.meta.glob(&#x27;../views/**/page.js&#x27;)console.log(pageModules) 观察打印结果发现，对象的属性名是对应的路径，值为动态导入函数，这些就是我们想要的配置啊 如果你希望对象的值不是动态导入的函数，官方文档上有一个globEager方法 1const pageModules = import.meta.globEager(&#x27;../views/**/page.js&#x27;) 在或者你指向要这个模块集合里的ddefault对象，那就稍微有点复杂了，不过，抱着死磕到底的心态，绝对尝试下，结果真给我搞出来了。下面是具体实现代码： 1const pages = Object.fromEntries(Object.entries(pageModules).map(([path, pageModule]) =&gt; [path, pageModule.default || &#123;&#125;])) 首先，我们使用Object.entries将模块对象pageModules转换为一个键值对数组，其中每个键值对都包含模块路径作为键和模块对象作为值。 接下来，我们使用map方法对这个数组进行遍历，对于每个键值对，我们都将其转换为一个包含模块路径作为键和模块对象default属性值作为值的键值对数组。这里使用了解构语法将path和pageModule分别指定为数组项的第一个和第二个元素，然后使用数组字面量的方式返回一个包含path和pageModule.default的新数组。 最后，我们使用Object.fromEntries将新数组转换为一个对象字面量，其中每个键值对都由原来的模块路径和default属性值组成。由于一些模块可能没有default属性值，所以我们使用|| &#123;&#125;语法将其设置为空对象，以防止在后续操作中出现undefined值的情况。 这样就处理好了我想要的数据，打印出来看下： 再来观察下这个对象，有3个对应的路径的属性和模块内容，说明我们应该有三个对应的路由配置。 这里通过 Object.entries() 方法将pages转为数组： 1const routes = Object.entries(pages) 接下来需要通过数组的map方法，将数组内的每一项，映射成路由配置，每一次映射，都要返回一个路由配置，比如下面这个： 123456return &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: &#123; title: &#x27;Home&#x27;, menuOrder: 1 &#125;&#125; 先找简单的，观察通过数组内的成员，config这个配置对应的就是meta对象，替换即可 123456return &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: config&#125; 接下来是路径，要把../views/about.page.js这个数组成员截取头尾，只留下/about，路径就出来了，首页的路径需要做点出来，以下是实现代码： 123456789const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) return &#123; path, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: config // config 就是 meta 的值，直接就能用 &#125;&#125;) 效果： 然后是路由name，具体看公司规定了，这里就简单点吧，比如/about，就将其命名为about 12345678910const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; return &#123; path, name, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: config &#125;&#125;) 看效果： 最后是component，数组对象内貌似有这个玩意，想这直接用 replace方法替换，结果运行时编辑器终端报错。。。 1234567891011const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; const compPath = pagePath.replace(&#x27;page.js&#x27;, &#x27;index.vue&#x27;) return &#123; path: path, name, component: () =&gt; import(compPath), meta: config &#125;&#125;) component对应的属性值变成了经过vite转换后的字面量，这不是我们想要的。 查阅资料后发现，因为vite是用rollup进行打包的，在这种环境内打包，有一个要求，就是import内不能放变量，要放字面量，不然会影响到其的静态分析。 这里想到在导入页面模块的时候，再去导入组件的模块，在import里就有我们想要的字面量了，这下就简单了，只需去取组件模块内的import字面量，替换到map方法内，就行了。 1234567891011const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; const compPath = pagePath.replace(&#x27;page.js&#x27;, &#x27;index.vue&#x27;) return &#123; path: path, name, component: compModules[compPath], meta: config &#125;&#125;) 再来看下数据结构： 最后，把先去为防止报错而赋值成空数组的routes去掉，大功告成了，附上/router/index.js文件完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;// const routes = [// &#123;// path: &#x27;/&#x27;,// name: &#x27;home&#x27;,// component: () =&gt; import(&#x27;../views/index.vue&#x27;),// meta: &#123; title: &#x27;Home&#x27;, menuOrder: 1 &#125;// &#125;,// &#123;// path: &#x27;/about&#x27;,// name: &#x27;about&#x27;,// component: () =&gt; import(&#x27;../views/about/index.vue&#x27;),// meta: &#123; title: &#x27;about&#x27;, menuOrder: 10 &#125;// &#125;,// &#123;// path: &#x27;/contact&#x27;,// name: &#x27;contact&#x27;,// component: () =&gt; import(&#x27;../views/contact/index.vue&#x27;),// meta: &#123; title: &#x27;contact&#x27;, menuOrder: 100 &#125;// &#125;,// ]const pageModules = import.meta.globEager(&#x27;../views/**/page.js&#x27;)const pages = Object.fromEntries(Object.entries(pageModules).map(([path, pageModule]) =&gt; [path, pageModule.default || &#123;&#125;]))const compModules = import.meta.glob(&#x27;../views/**/index.vue&#x27;)const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; const compPath = pagePath.replace(&#x27;page.js&#x27;, &#x27;index.vue&#x27;) return &#123; path: path, name, component: compModules[compPath], meta: config &#125;&#125;)export const router = createRouter(&#123; history: createWebHashHistory(), routes&#125;) 页面效果： App.vue完整代码： 12345678910111213141516171819202122232425262728293031323334&lt;script setup&gt;import &#123; watchEffect, ref &#125; from &#x27;vue&#x27;import &#123; router &#125; from &#x27;./router&#x27;const routes = ref(router.getRoutes())watchEffect(() =&gt; (routes.value = router.getRoutes))const onUpdated = () =&gt; (routes.value = router.getRoutes())router.afterEach(onUpdated)&lt;/script&gt;&lt;template&gt; &lt;nav&gt; &lt;router-link v-for=&quot;route in routes&quot; :key=&quot;route.path&quot; :to=&quot;route.path&quot;&gt;&#123;&#123; route.meta.title &#125;&#125;&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;nav &#123; text-align: center;&#125;nav &gt; a &#123; margin-left: 20px; text-decoration: none;&#125;&lt;/style&gt; 在此基础上，如果需要新增页面的时候，只需在views文件夹加内新建对应的页面文件并带上page.js配置文件，就可不用再手动配置路由了。","categories":[],"tags":[{"name":"Vite","slug":"Vite","permalink":"http://example.com/tags/Vite/"}]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Vite","slug":"Vite","permalink":"http://example.com/tags/Vite/"}]}