{"meta":{"title":"WessonChen","subtitle":"","description":"","author":"WessonChen","url":"http://example.com","root":"/"},"pages":[{"title":"About Us","date":"2023-04-23T10:10:45.511Z","updated":"2023-04-23T10:10:45.500Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":".about { background-color: #f2f2f2; padding: 50px 0; } .about h1 { margin: 0 0 20px; font-size: 36px; font-weight: bold; text-align: center; } .about p { margin: 0 0 20px; font-size: 18px; line-height: 1.5; text-align: justify; } .container { max-width: 960px; margin: 0 auto; padding: 0 20px; } About Me Hello, welcome to my personal blog. I'm Wesson, a Front End Engineer, From Guangdong, China. development. I enjoy constantly learning and improving in my work to provide the best service for my team and clients. So I created this blog to share some views and ideas on front-end development I'm passionate about the development of the frontend, and I have more than 4 years of experience in this field. I'm proficient in tools and technologies such as Vue2, Vue3, Uni-app, JavaScript, HTML5, CSS3, which enable me to develop high-quality frontend projects. Aside from my work, I also enjoy fishing, playing [Nintendo Switch] and meditation, which help me maintain balance and vitality. I hope that my skills and experience can contribute to your projects and team, and I look forward to collaborating with you to achieve success. Welcome to learn and exchange ideas with each other"}],"posts":[{"title":"整理了一些近些年项目中用到的工具函数","slug":"整理了一些近些年项目中用到的工具函数","date":"2023-03-10T13:26:00.000Z","updated":"2023-04-23T10:22:27.019Z","comments":true,"path":"2023/03/10/整理了一些近些年项目中用到的工具函数/","link":"","permalink":"http://example.com/2023/03/10/%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%BA%9B%E8%BF%91%E4%BA%9B%E5%B9%B4%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"工具函数 数字操作 生成指定范围随机数1export const randomNum = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + min; 数字千分位分隔符123456789101112131415161718export const format = (n) =&gt; &#123; let num = n.toString(); let len = num.length; if (len &lt; 3) &#123; return num; &#125; else &#123; let temp = &quot;&quot;; let remainder = len % 3; // 不是3的整倍数 if (remainder &gt; 0) &#123; return ( num.slice(0, remainder) + &quot;,&quot; + num.slice(remainder, len).match(/\\d&#123;3&#125;/g).join(&quot;,&quot;) + temp); &#125; else &#123; return num.slice(0, len).match(/\\d&#123;3&#125;/g).join(&quot;,&quot;) + temp; &#125; &#125;&#125;; 数组操作 数组乱序123456export const arrScrambling = arr =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i; ([arr[i], arr[randomIndex]] = [arr[randomIndex]]), arr[i]; &#125;&#125;; 数组扁平123456789export const flatten = (arr) =&gt; &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; Array.isArray(arr[i]) ? (result = result.concat(flatten(arr[i]))) : result.push(arr[i]); &#125; return;&#125;; 数组中获取随机数1export const sample = (arr) =&gt; arr[Math.floor(Math.random() * arr.length)]; 字符串操作 随机生成字符串12345678export const randomString = (len) =&gt; &#123; let chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789&quot;; let strLen = chars.length; let randomStr = &quot;&quot;; for (let i = 0; i &lt; len; i++) &#123; randomStr += chars.charAt(Math.floor(Math.random() * strLen)); &#125;&#125;; 字符串首字母大写1export const fistLetterUpper = (str) =&gt; str.charAt(0).toUpperCase() + str.slice(1); 手机号中间四位替换成12345export const telFormat = (tel) =&gt; &#123; tel = String(tel); return tel.substr(0, 3) + &quot;****&quot; + tel.substr(7);&#125;; 驼峰命名转换为短横线命名1export const getKebabCase = str =&gt; str.replace(/[A-Z]/g, item =&gt; &#x27;-&#x27; + item.toLowerCase()) 短横线命名转换为驼峰命名1export const getCamelCase = str =&gt; str.replace(/-([a-z])/g, item =&gt; item.toUpperCase()) 全角转半角1234567891011121314export const toCDB = str =&gt; &#123; let result = &#x27;&#x27; for (let i = 0; i &lt; str.length; i++) &#123; code = str.charCodeAt(i) if (code &gt;= 65281 &amp;&amp; code &lt;= 65374) &#123; result += String.fromCharCode(str.charCodeAt(i) - 65248) &#125; else if (code == 12288) &#123; result += string.fromCharCode(str.charCodeAt(i) - 12288 + 32) &#125; else &#123; result += str.charAt(i) &#125; &#125; return result&#125; 半角转换为全角1234567891011121314export const toDBC = (str) =&gt; &#123; let result = &#x27;&#x27; for (let i = 0; i &lt; str.length; i++) &#123; code = str.charCodeAt(i) if (code &gt;= 33 &amp;&amp; code &lt;= 126) &#123; result += String.fromCharCode(str.charCodeAt(i) + 65248) &#125; else if (code == 32) &#123; result += String.fromCharCode(str.charCodeAt(i) + 12288 - 32) &#125; else &#123; result += str.charAt(i) &#125; &#125; return result&#125; 格式转化 数字转大写123456789101112131415161718192021222324export const digitUppercase = (n) =&gt; &#123; const fraction = [&#x27;角&#x27;, &#x27;分&#x27;] const digit = [&#x27;零&#x27;, &#x27;壹&#x27;, &#x27;贰&#x27;, &#x27;叁&#x27;, &#x27;肆&#x27;, &#x27;伍&#x27;, &#x27;陆&#x27;, &#x27;柒&#x27;, &#x27;捌&#x27;, &#x27;玖&#x27;] const unit = [ [&#x27;元&#x27;, &#x27;万&#x27;, &#x27;亿&#x27;], [&#x27;&#x27;, &#x27;拾&#x27;, &#x27;佰&#x27;, &#x27;仟&#x27;], ] n = Math.abs(n) let s = &#x27;&#x27; for (let i = 0; i &lt; fraction.length; i++) &#123; s += digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i].replace(/零./, &#x27;&#x27;) &#125; s = s || &#x27;整&#x27; n = Math.floor(n) for (let i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123; let p = &#x27;&#x27; for (let j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123; p = digit[n % 10] + unit[1][1] + p n = Math.floor(n / 10) &#125; s = p.replace(/(零.)*零$/, &#x27;&#x27;).replace(/^$/, &#x27;零&#x27;) + unit[0][i] + s &#125; return s.replace(/(零.)*零元$/, &#x27;元&#x27;).replace(/(零.)+/g, &#x27;零&#x27;).replace(/^整$/, &#x27;零元整&#x27;)&#125;; 数字转中文数字1234567891011121314151617181920212223242526272829export const intToChinese = (value) =&gt; &#123; const str = String(value); const len = str.length - 1; const idxs = [ &#x27;&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;万&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;亿&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;万&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;千&#x27;, &#x27;亿&#x27; ]; const num = [ &#x27;零&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;, &#x27;七&#x27;, &#x27;八&#x27;, &#x27;九&#x27;, &#x27;十&#x27; ]; return str.replace(/([1-9]|0+)/g, ($, $1, idx, full) =&gt; &#123; let pos = 0 if ($1[0] !== &#x27;0&#x27;) &#123; pos = len - idx if (idx == 0 &amp;&amp; $1[0] == 1 &amp;&amp; idxs[len - idx] == &#x27;十&#x27;) &#123; return idxs[len - idx] &#125; return num[$1[0]] + ids[len - idx] &#125; else &#123; let left = len - idx let right = len - idx + $1.length if (Math.floor(right / 4) - Math.f1oor(left / 4) &gt; 0) &#123; pos = left - (left % 4) &#125; if (pos) &#123; return idxs[pos] + num[$1[0]] &#125; else if (idx + $1.length &gt;= len) &#123; return &#x27;&#x27; &#125; else &#123; return num[$1[0]] &#125; &#125; &#125;)&#125;; 浏览器存储操作 存loalStorage12345export const loalStorageSet = (key, value) =&gt; &#123; if (!key) return; if (typeof value !== &#x27;string&#x27;) value = JSON.stringify(value); window.localStorage.setItem(key, value);&#125;; 取loalStorage1234export const loalStorageGet = key =&gt; &#123; if (!key) return return window.localStorage.getItem(key)&#125;; 删loalStorage1234export const loalStorageRemove = key =&gt; &#123; if (!key) return return window.localStorage.removeItem(key)&#125;; 存sessionStorage12345export const sessionStirageSet = (key, value) =&gt; &#123; if (!key) return if (typeof value !== &#x27;string&#x27;) value = JSON.stringify(value) window.sessionStorage.setItem(key, value)&#125;; 取sessionStorage1234export const sessionStirageGet = key =&gt; &#123; if (!key) return return window.sessionStorage.getItem(key)&#125;; 删sessionStorage12345export const sessionStirageRemove = key =&gt; &#123; if (!key) return window.sessionStorage.removeItem(key)&#125;; 存cookie12345export const setCookie = (key, value, expire) =&gt; &#123; const d = new Date() d.setDate(d.getDate() + expire) document.cookie = `$&#123;key&#125;=$&#123;value&#125;;expires=$&#123;d.toUTCString()&#125;`&#125;; 取cookie12345678910111213export const getCookie = (key) =&gt; &#123; const cookieStr = unescape(document.cookie) const arr = cookieStr.split(&#x27;;&#x27;) let cookieValue = &#x27;&#x27; for (let i = 0; i &lt; arr.length; i++) &#123; const temp = arr[i].split(&#x27;=&#x27;) if (temp[0] === key) &#123; cookieValue = temp[1] break &#125; &#125; return cookieValue&#125;; 删cookie1export const delCookie = key =&gt; (document.cookie = `$&#123;encodeURIComponent(key)&#125;=;expires=$&#123;new Date()&#125;`); 格式校验 校验身份证号码1234export const checkCardNo = value =&gt; &#123; let reg = /(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|x|x$))/ return reg.test(value)&#125;; 校验是否包含中文1export const haveCNChars = value =&gt; /[\\u4e00-\\u9fa5]/.test(value); 校验邮箱地址1export const isEmail = value =&gt; /^[a-zA=Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/.test(value); 校验是否为中国大陆的邮政编码1export const isPostCode = value =&gt; /^[1-9][0-9]257$/.test(value.toString()); 校验是否为1Pv6地址123456789export const isIPv6 = (str) =&gt; &#123; return Boolean( str.match(/:g/) ? str.match(/:g/).length &lt;= 7 : false &amp;&amp; /::/.test(str) ? /^([\\da-f]&#123;1,4&#125;(:|::))&#123;1, 6&#125;[\\da-f]&#123;1,4&#125;$/i.test(str) : /^([\\da-f]&#123;1,4&#125;:)&#123;7&#125;[\\da-f]&#123;1,4&#125;$/i.test(str) )&#125; 校验手机号码1export const isTel = value =&gt; /^1[3,4.5.6,7,8,9][0-9]&#123;9&#125;$/.test(value.tostring()) 检验是否包含emoji表情1234567891011121314151617181920212223242526272829303132333435export const isEmojiCharacter = (value) =&gt; &#123; value = String(value); for (let i = 0; i &lt; value.length; i++) &#123; const hs = value.charCodeAt(i); if (0xd800 &lt; hs &amp;&amp; hs &lt;= 0xdbff) &#123; const ls = value.charCodeAt(i + 1); const uc = (hs - 0xd800) * 0x400 + (ls - oxdc00) + 0x10000; if (0x1d00 &lt;= uc &amp;&amp; uc &lt;= 0x1f77f) return true; &#125; else if (value.len &gt; 1) &#123; const ls = value.charCodeAt(i + 1); if (ls == 0x20e4) return true; &#125; else &#123; if (0x2100 &lt;= hs &amp;&amp; hs &lt;= 0x2b07) &#123; return true; &#125; else if (0x2b05 &lt;= hs &amp;&amp; hs &lt;= 0x2b07) &#123; return true; &#125; else if (0x2934 &lt;= hs &amp;&amp; hs &lt;= 0x2935) &#123; return true; &#125; else if (0x3297 &lt;= hs &amp;&amp; hs &lt;= 0x3299) &#123; return true; &#125; else if ( hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 ) return true; &#125; &#125; return false;&#125;; 操作URL 获取URL参数123456789101112131415161718192021export const getRequest = () =&gt; &#123; let url = location.search const paramsStr = /.+\\?(.+)$/.exec(url)[1] const paramsArr = paramsStr.split(&#x27;&amp;&#x27;) let paramsObj = &#123;&#125; paramsArr.forEach(param =&gt; &#123; if (/=/.test(param)) &#123; let [key, val] = param.split(&#x27;=&#x27;) val = decodeURIComponent(val) val = /^\\d+$/.test(val) ? parseFloat(val) : val if (paramsObj.hasOwnProperty(key)) &#123; paramsObj[key] = [].concat(paramsObj[key], val) &#125; else &#123; paramsObj[key] = val &#125; &#125; else &#123; paramsObj[param] = true &#125; &#125;) return paramsObj&#125; 检测URL是否有效1234567891011export const getUriState = (URL) =&gt; &#123; let xmlhttp = new ActiveXObject(&#x27;microsoft.xmlhttp&#x27;); xmilhttp.Open(&#x27;GET&#x27;, URL, false); try &#123; xmlhttp.Send(); &#125; catch (e) &#123; &#125; finally &#123; let result = xmlhttp.responseText; result ? (xmlhttp.Status == 200 ? true : false) : false; &#125;&#125;; 键值对拼接成URL参数1234567export const params2URL = obj =&gt; &#123; let params = [] for(let key in obj) &#123; params.push(`$&#123;key&#125;=$&#123;obj[key]&#125;`) &#125; return encodeURIComponent(params.join(&#x27;&amp;&#x27;))&#125; 修改URL中的参数123456export const replaceParamVal = (paramName, replacewith) =&gt; &#123; const oUrl = location.href.toString() const re = eval(&#x27;/ (&#x27; + paramName + &#x27;=)([^&amp;]*)/gi&#x27;) location.href = oUrl.replace(re, paramName + &#x27;=&#x27; + replaceWith) return location.href&#125;; 设备判断 判断移动端或是PC端123456export const isMobile = () =&gt; &#123; if (navigator.userAgent.match(/(iPhone|iPod|Android|ios|i0S|iPad|Backerry|WebOS|Symbian|Windows Phone|Phone)/i)) &#123; return &#x27;mobile&#x27; &#125; return &#x27;desktop&#x27;&#125;; 判断是否是苹果还是安卓移动设备1234export const isAppleMobileDevice = () =&gt; &#123; let reg = /iphone|ipod|ipad|Macintosh/i return reg.test(navigator.userAgent.toLowerCase())&#125;; 判断是否是安卓移动设备123export const isAndroidMobileDevice = () =&gt; &#123; return /android/i.test(navigator.userAgent.toLowerCase())&#125;; 判断系统是Windows还是Mac123456789101112131415export const osType = () =&gt; &#123; const agent = navigator.userAgent.toLowerCase(); const isMac = /macintosh|mac os x/i.test(navigator.userAgent); const isWindows = agent.index0f(&quot;win64&quot;) &gt;= 0 || agent.indexOf(&quot;wow64&quot;) &gt;= 0 || agent.index0f(&quot;win32&quot;) &gt;= 0 || agent.index0f(&quot;wow32&quot;) &gt;= 0 if (isWindows) &#123; return &quot;windows&quot; &#125; if (isMac) &#123; return &quot;mac&quot; &#125;&#125;; 判断是否是微信&#x2F;QQ内置浏览器123456789export const broswer = () =&gt; &#123; const ua = navigator.userAgent.toLowerCase() if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123; return &quot;weixin&quot; &#125; else if (ua.match(/QQ/i) == &quot;qq&quot;) &#123; return &quot;QQ&quot; &#125; return false;&#125;; 获取浏览器型号和版本123456789101112131415161718export const getExplorerInfo = () =&gt; &#123; let t = navigator.userAgent.toLocaleLowerCase() return 0 &lt;= t.indexOf(&#x27;msie&#x27;) ? &#123; type: &#x27;IE&#x27;, version: Number(t.match(/msie ([\\d]+)/)[1]) &#125; : !!t.match(/trident\\/.+?rv:(([\\d.]+))/) ? &#123; type: &#x27;IE&#x27;, version: 11 &#125; : 0 &lt;= t.indexOf(&#x27;edge&#x27;) ? &#123; type: &#x27;Edge&#x27;, version: Number(t.match(/edge\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;firefox&#x27;) ? &#123; type: &#x27;Firefox&#x27;, version: Number(t.match(/firefox\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;chrome&#x27;) ? &#123; type: &#x27;Firefox&#x27;, version: Number(t.match(/chrome\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;opera&#x27;) ? &#123; type: &#x27;Opera&#x27;, version: Number(t.match(/opera\\/([\\d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(&#x27;Safari&#x27;) ? &#123; type: &#x27;Safari&#x27;, version: Number(t.match(/Safari\\/([\\d]+)/)[1]) &#125; : &#123; type: t, version: -1 &#125;&#125;; 浏览器操作 滚动到页面顶部1234567export const scrollToTop = () =&gt; &#123; const height = document.documentElement.scrollTop || document.body.scrollTop; if (height &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, height - height / 8); &#125;&#125;; 滚动至底部1export const scrollToBottom = () =&gt; window.scrollTo(0, document.documentElement.clientHeight); 滚动到指定元素区域1export const smoothScroll = element =&gt; document.querySelector(element).scrollIntoView(&#123; behavior: &#x27;smooth&#x27; &#125;); 获取可视窗口宽度1export const getPageViewWidth = () =&gt; (document.compatMode = &quot;BackCompat&quot; ? document.body: document.documentElement).clientWidth 获取可视窗口高度123456789export const getClienHeight = () =&gt; &#123; let clientHeight = 0 if (document.body.clientHeight &amp;&amp; document.documentElement.clientHeight) &#123; clientHeight = (document.body.clientHeight &lt; document.documentElement.clientHeight) ? document.body.clientHeight : document.documentElement.clientHeight &#125; else &#123; clientHeight = (document.body.clientHeight &gt; document.documentElement.clientHeight) ? document.body.clientHeight : document,documentElement.clientHeight &#125; return clientHeight&#125; 打开浏览器全屏123456789101112export const toFullScreen = () =&gt; &#123; let element = document.body if (element.requestFullscreen) &#123; element.requestFul1screen() &#125; else if (element.mozRequestFu11Screen) &#123; element.mozRequestFul1Screen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFul1screen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFul1Screen() &#125;&#125;; 时间操作 获取当前时间12345678910export const nowTime = () =&gt; &#123; const now = new Date() const year = now.getFullYear() const month = now.getMonth() const date = now.getDate() &gt;= 10 ? now.getDate() : &#x27;0&#x27; + now.getDate() const hour = now.gethours() &gt;= 10 ? now.getHours() : &#x27;0&#x27; + now.gethours() const miu = now.getMinutes() &gt;= 10 ? now.getMinutes0 : &#x27;日&#x27; + now.getMinutes() const sec = now.getSeconds() &gt;= 10 ? now.getSeconds() : &#x27;0&#x27; + now.getSeconds() return +year + &#x27;年&#x27; + (month + 1) + &#x27;月&#x27; + date + &#x27;日 &#x27; + hour + &#x27;:&#x27; + miu + &#x27;:&#x27; + sec&#125;; 格式化时间12345678910111213141516171819export const dateFormater = (formater, time) =&gt; &#123; let date = time ? new Date(time) : new Date(); Y = date.getFullYear() + &#x27;&#x27; M = date.getMonth() + 1 D = date.getDate() H = date.getHours() m = date.getMinutes() s = date.getSeconds() return formater .replace(/YYYY||yyyy/g, Y) .replace(/YY|yy/g, Y.substr(2, 2)) .replace(/MM/g, M &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27; + M) .replace(/DD/g, D &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27; + D) .replace(/HH|hh/g, (H &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + H) .replace(/mm/g, (m &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + s) .replace(/ss/g, (s &lt; 10 ? &#x27;0&#x27; : &#x27;&#x27;) + s)&#125;;// dateFormater(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)// dateFormater(&#x27;YYYYMMDDHHmmss&#x27;) JavaScript操作 阻止事件冒泡1234export const stopPropagation = e =&gt; &#123; e = e || window.event e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true&#125; 防抖函数1234567891011121314export const debounce = (fn, wait) =&gt; &#123; let timer = null return function () &#123; let context = this, args = arguments if (timer) &#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125;; 节流函数123456789101112export const throttle = (fn, delay) =&gt; &#123; let curTime = Date.now() return function () &#123; let context = this args = arguments nowTime = Date.now() if (nowTime - curTime &gt;= delay) &#123; curTime = Date.now() return fn.apply(context, args) &#125; &#125;&#125;; 数据类型判断1234567891011121314export const getType = (value) =&gt; &#123; if (value === null) &#123; return value + &#x27;&#x27; &#125; if (typeof value === &#x27;object&#x27;) &#123; // 判断数据是引用类型的情况 let valueClass = Object.prototype.toString.call(value), type = valueClass.split(&#x27; &#x27;)[1].split(&#x27;&#x27;) type.pop() return type.join(&#x27;&#x27;).toLoweICase() &#125; else &#123; // 判断数据是基本数据类型的情况和两数的情况 return typeof value &#125;&#125;; 对象深拷贝123456789101112131415161718192021222324252627export const deepClone = (obj, hash = new WeakMap()) =&gt; &#123; // 日期对象直接返回一个新的日期对象 if (obj instanceof Date) &#123; return new Date(obj) &#125; // 正则对象直接返回一个新的正则对象 if (obi instanceof ResExp) &#123; return new RegExp(obj) &#125; // 如果循环引用，就用 weakMap 来解决 if (hash.has(obj)) &#123; return hash.get(obj) &#125; // 获取对象所有自身屁性的描述 let allDesc = Object.getOwnPropertyDescriptors(obi) // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc) hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obi)) &#123; if (typeof obj[key] === &#x27;object&#x27; &amp;&amp; obj[key] !== null) &#123; cloneObj[key] = deepClone(obj[key], hash) &#125; else &#123; cloneObj[key] = obi[key] &#125; &#125; return cloneObj&#125;;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"在Vite中使用glob完成自动生成Router规则","slug":"在Vite中使用glob完成自动生成Router规则","date":"2022-03-04T11:04:00.000Z","updated":"2023-04-23T10:22:33.035Z","comments":true,"path":"2022/03/04/在Vite中使用glob完成自动生成Router规则/","link":"","permalink":"http://example.com/2022/03/04/%E5%9C%A8Vite%E4%B8%AD%E4%BD%BF%E7%94%A8glob%E5%AE%8C%E6%88%90%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Router%E8%A7%84%E5%88%99/","excerpt":"","text":"&amp;#x20;我们在工作当中，其实会遇到很多的体力活，它没有什么技术含量，但你还不得不做，比方说像这个路由配置： 12345678910111213141516171819202122232425import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;index&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: &#123; title: &#x27;首页&#x27;, menuOrder: 1 &#125; &#125;, &#123; path: &#x27;&#x27;, name: &#x27;&#x27;, component: () =&gt; import(&#x27;../views/about/index.vue&#x27;), meta: &#123; title: &#x27;关于&#x27;, menuOrder: 1 &#125; &#125;, &#123; path: &#x27;&#x27;, name: &#x27;&#x27;, component: () =&gt; import(&#x27;../views/contact/index.vue&#x27;), meta: &#123; title: &#x27;联系&#x27;, menuOrder: 1 &#125; &#125;,]export const router = createRouter(&#123; history: createWebHashHistory(), routes&#125;) 有没感觉路由配置就是一个纯粹的体力活，但你又不得不干的体力活？ 如果你的心思足够细腻，你还会感觉到这个玩意儿有点像重复代码，但是你又说不好哪里重复了。你的感觉是非常正确的，它就是重复代码，它跟谁重复了呢？跟我们的目录结构重复了。看看对比： 为什么要把它写一遍呢？ 其实我们软件工程里边早就出现了一个概念，叫做：约定大于配置，就是在我们实际开发中，公司往往会给予很多的开发规范，在这些规范里边其实就已经暗含了配置了 比如about页面，需要建一个文件夹，它的页面组件是/views/about/index.vue，contact页面也同理。按照这样的规范去写出来的目录，它其实就是路由配置 那我现在要想一想了，既然如此啊，我们能不能找到一个办法，就是在代码里边自动帮我们生成路由配置，不用去手动写； 手动写的还经常写错，单词写错，大小写写错，然后呢，导入路径写错，增加了不少的错误几率，而且将来这个目录结构一改，如果说你这里忘记了更改，还要造成很多的隐患，那么如果说能够自动生成的话，这些问题都不复存在了，那怎么来做呢？ 此时我想，能否对/router/index.js文件内定义的routes这个路由配置做文章？ 参考小程序的做法，为每一个页面呢写上一个配置，用json或js都行，导出一个配置meta中缺失的配置 12345export default &#123; title: &#x27;Home&#x27;, menuOrder: 1&#125; 同样的道理呢，我们把这个配置呢，应用到每一个页面，每一个页面带一个配置，换句话说，只要有这个配置，它就是一个页面，没有这个配置它就不是一个页面， 这么配置后，当每次新建页面，把这个配置给它带上就完事了。这么一来，信息就完整了，我们就可以大胆的不再使用手动的书写方式了啊，为了避免报错呢，暂时的给/router/index.js文件内导出的routes配置为一个空数组，然后将routes自动生成 怎么生成？如果说你用的是vue-cli，由于它背后使用了Webpack，那么你可以利用里边的**require.context()**来进行批量导入，用它可以把views文件夹下边的所有你需要的文件都一起导入进来，比方说你要找到它里边的所有page.js可以全部导入进来。 由于我这里用的是viet，它背后不是Webpack，上述方法用不了。在vite里边呢，它也有相同的方式来做同样的事情，这种方式呢，叫做glob； 通过查看官方文档发现，这是一个函数，给它传入一个匹配规则，它就能找到这个文件夹下边的所有的相应文件，把这些文件导入进来，生成一个模块的集合。 比方说我要匹配不views文件夹下边的所有的page.js的文件， 12const pageModules = import.meta.glob(&#x27;../views/**/page.js&#x27;)console.log(pageModules) 观察打印结果发现，对象的属性名是对应的路径，值为动态导入函数，这些就是我们想要的配置啊 如果你希望对象的值不是动态导入的函数，官方文档上有一个globEager方法 1const pageModules = import.meta.globEager(&#x27;../views/**/page.js&#x27;) 在或者你指向要这个模块集合里的ddefault对象，那就稍微有点复杂了，不过，抱着死磕到底的心态，绝对尝试下，结果真给我搞出来了。下面是具体实现代码： 1const pages = Object.fromEntries(Object.entries(pageModules).map(([path, pageModule]) =&gt; [path, pageModule.default || &#123;&#125;])) 首先，我们使用Object.entries将模块对象pageModules转换为一个键值对数组，其中每个键值对都包含模块路径作为键和模块对象作为值。 接下来，我们使用map方法对这个数组进行遍历，对于每个键值对，我们都将其转换为一个包含模块路径作为键和模块对象default属性值作为值的键值对数组。这里使用了解构语法将path和pageModule分别指定为数组项的第一个和第二个元素，然后使用数组字面量的方式返回一个包含path和pageModule.default的新数组。 最后，我们使用Object.fromEntries将新数组转换为一个对象字面量，其中每个键值对都由原来的模块路径和default属性值组成。由于一些模块可能没有default属性值，所以我们使用|| &#123;&#125;语法将其设置为空对象，以防止在后续操作中出现undefined值的情况。 这样就处理好了我想要的数据，打印出来看下： 再来观察下这个对象，有3个对应的路径的属性和模块内容，说明我们应该有三个对应的路由配置。 这里通过 Object.entries() 方法将pages转为数组： 1const routes = Object.entries(pages) 接下来需要通过数组的map方法，将数组内的每一项，映射成路由配置，每一次映射，都要返回一个路由配置，比如下面这个： 123456return &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: &#123; title: &#x27;Home&#x27;, menuOrder: 1 &#125;&#125; 先找简单的，观察通过数组内的成员，config这个配置对应的就是meta对象，替换即可 123456return &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: config&#125; 接下来是路径，要把../views/about.page.js这个数组成员截取头尾，只留下/about，路径就出来了，首页的路径需要做点出来，以下是实现代码： 123456789const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) return &#123; path, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: config // config 就是 meta 的值，直接就能用 &#125;&#125;) 效果： 然后是路由name，具体看公司规定了，这里就简单点吧，比如/about，就将其命名为about 12345678910const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; return &#123; path, name, component: () =&gt; import(&#x27;../views/index.vue&#x27;), meta: config &#125;&#125;) 看效果： 最后是component，数组对象内貌似有这个玩意，想这直接用 replace方法替换，结果运行时编辑器终端报错。。。 1234567891011const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; const compPath = pagePath.replace(&#x27;page.js&#x27;, &#x27;index.vue&#x27;) return &#123; path: path, name, component: () =&gt; import(compPath), meta: config &#125;&#125;) component对应的属性值变成了经过vite转换后的字面量，这不是我们想要的。 查阅资料后发现，因为vite是用rollup进行打包的，在这种环境内打包，有一个要求，就是import内不能放变量，要放字面量，不然会影响到其的静态分析。 这里想到在导入页面模块的时候，再去导入组件的模块，在import里就有我们想要的字面量了，这下就简单了，只需去取组件模块内的import字面量，替换到map方法内，就行了。 1234567891011const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; const compPath = pagePath.replace(&#x27;page.js&#x27;, &#x27;index.vue&#x27;) return &#123; path: path, name, component: compModules[compPath], meta: config &#125;&#125;) 再来看下数据结构： 最后，把先去为防止报错而赋值成空数组的routes去掉，大功告成了，附上/router/index.js文件完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;// const routes = [// &#123;// path: &#x27;/&#x27;,// name: &#x27;home&#x27;,// component: () =&gt; import(&#x27;../views/index.vue&#x27;),// meta: &#123; title: &#x27;Home&#x27;, menuOrder: 1 &#125;// &#125;,// &#123;// path: &#x27;/about&#x27;,// name: &#x27;about&#x27;,// component: () =&gt; import(&#x27;../views/about/index.vue&#x27;),// meta: &#123; title: &#x27;about&#x27;, menuOrder: 10 &#125;// &#125;,// &#123;// path: &#x27;/contact&#x27;,// name: &#x27;contact&#x27;,// component: () =&gt; import(&#x27;../views/contact/index.vue&#x27;),// meta: &#123; title: &#x27;contact&#x27;, menuOrder: 100 &#125;// &#125;,// ]const pageModules = import.meta.globEager(&#x27;../views/**/page.js&#x27;)const pages = Object.fromEntries(Object.entries(pageModules).map(([path, pageModule]) =&gt; [path, pageModule.default || &#123;&#125;]))const compModules = import.meta.glob(&#x27;../views/**/index.vue&#x27;)const routes = Object.entries(pages).map(([pagePath, config]) =&gt; &#123; const path = (pagePath.replace(&#x27;../views&#x27;, &#x27;&#x27;).replace(&#x27;/page.js&#x27;, &#x27;&#x27;) || &#x27;/&#x27;) const name = path.split(&#x27;/&#x27;).filter(Boolean).join(&#x27;-&#x27;) || &#x27;home&#x27; const compPath = pagePath.replace(&#x27;page.js&#x27;, &#x27;index.vue&#x27;) return &#123; path: path, name, component: compModules[compPath], meta: config &#125;&#125;)export const router = createRouter(&#123; history: createWebHashHistory(), routes&#125;) 页面效果： App.vue完整代码： 12345678910111213141516171819202122232425262728293031323334&lt;script setup&gt;import &#123; watchEffect, ref &#125; from &#x27;vue&#x27;import &#123; router &#125; from &#x27;./router&#x27;const routes = ref(router.getRoutes())watchEffect(() =&gt; (routes.value = router.getRoutes))const onUpdated = () =&gt; (routes.value = router.getRoutes())router.afterEach(onUpdated)&lt;/script&gt;&lt;template&gt; &lt;nav&gt; &lt;router-link v-for=&quot;route in routes&quot; :key=&quot;route.path&quot; :to=&quot;route.path&quot;&gt;&#123;&#123; route.meta.title &#125;&#125;&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;style&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;nav &#123; text-align: center;&#125;nav &gt; a &#123; margin-left: 20px; text-decoration: none;&#125;&lt;/style&gt; 在此基础上，如果需要新增页面的时候，只需在views文件夹加内新建对应的页面文件并带上page.js配置文件，就可不用再手动配置路由了。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Vite","slug":"Vite","permalink":"http://example.com/tags/Vite/"}]},{"title":"学习TypeScript 8 (Class类)","slug":"学习TypeScript 8 (Class类)","date":"2022-02-24T15:54:00.000Z","updated":"2023-04-23T15:48:24.689Z","comments":true,"path":"2022/02/24/学习TypeScript 8 (Class类)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%208%20(Class%E7%B1%BB)/","excerpt":"","text":"Class类 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。12345678910// 定义类class Person &#123; constructor() &#123; &#125; run() &#123; &#125;&#125; 1. 在TypeScript中定义类 在TypeScript中是不允许直接在constructor 定义变量的，需要在constructor上面先声明 这样引发了第二个问题你如果了定义了变量不用，也会报错；通常是给个默认值 或者 进行赋值(此处关闭了Eslint检查，所以没报错) 到这，恭喜你已经学会了在class中如何定义变量了。 2.类的修饰符 总有有3个： 修饰符 描述 public 可以让定义的变量在内部访问，也可以外部访问[^注释1] private 代表定义的变量私有的只能在内部访问，不能在外部访问 protected 代表定义变量是私有的，只能在内部和继承的子类中访问 使用public 修饰符：可以让你定义的变量，内部访问，也可以外部访问；如果不写默认就是public 使用 private修饰符：代表定义的变量私有的只能在内部访问，不能在外部访问 使用 private修饰符：代表定义的变量私有的只能在内部访问，不能在外部访问 使用 protected修饰符：代表定义的变量私有的只能在内部和继承的子类中访问，不能在外部访问 3. static 静态属性 和 静态方法 使用static定义属性是，不可通过this去访问，只能通过类名去调用 static 静态函数 同样也是不能通过this去调用，也是通过类名去调用 需注意的是： 如果两个函数都是static 静态的是可以通过this互相调用 interface定义类 TypeScript中interface 定义类，使用关键字 implements ，后面跟interface的名字多个用逗号隔开，继承还是用extends 1234567891011121314151617181920212223242526272829interface PersonClass &#123; get(type: boolean): boolean&#125; interface PersonClass2&#123; set():void, asd:string&#125; class A &#123; name: string constructor() &#123; this.name = &quot;123&quot; &#125;&#125; class Person extends A implements PersonClass,PersonClass2 &#123; asd: string constructor() &#123; super() this.asd = &#x27;123&#x27; &#125; get(type:boolean) &#123; return type &#125; set () &#123; &#125;&#125; 5.抽象类 应用场景： 如果你写的类实例化之后毫无用处此时我可以把他定义为抽象类 或者你也可以把他作为一个基类 -&gt; 通过继承一个派生类去实现基类的一些方法 例子 下面这段代码会报错抽象类无法被实例化123456abstract class A &#123; public name:string &#125; new A() 例子2 在A类定义了 getName 抽象方法但为实现 B类实现了A定义的抽象方法，如不实现就不报错； 我们定义的抽象方法必须在派生类实现123456789101112131415161718192021222324abstract class A &#123; name: string constructor(name: string) &#123; this.name = name; &#125; print(): string &#123; return this.name &#125; abstract getName(): string&#125; class B extends A &#123; constructor() &#123; super(&#x27;小满&#x27;) &#125; getName(): string &#123; return this.name &#125;&#125; let b = new B(); console.log(b.getName()); 完整案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 1. class 的基本用法 继承 和 类型约束// 2. class 的修饰符 readonly private protected public// 3. super 原理// 4. 静态方法// 5. get setinterface Options &#123; el: string | HTMLElement&#125; interface VueCls &#123; init(): void options: Options&#125; interface Vnode &#123; tag: string text?: string props?: &#123; id?: number | string key?: number | string | object &#125; children?: Vnode[]&#125; class Dom &#123; constructor() &#123; &#125; private createElement(el: string): HTMLElement &#123; return document.createElement(el) &#125; protected setText(el: Element, text: string | null) &#123; el.textContent = text; &#125; protected render(createElement: Vnode): HTMLElement &#123; const el = this.createElement(createElement.tag) if (createElement.children &amp;&amp; Array.isArray(createElement.children)) &#123; createElement.children.forEach(item =&gt; &#123; const child = this.render(item) this.setText(child, item.text ?? null) el.appendChild(child) &#125;) &#125; else &#123; this.setText(el, createElement.text ?? null) &#125; return el; &#125;&#125; class Vue extends Dom implements VueCls &#123; options: Options constructor(options: Options) &#123; super() this.options = options; this.init() &#125; static version () &#123; return &#x27;1.0.0&#x27; &#125; public init() &#123; let app = typeof this.options.el == &#x27;string&#x27; ? document.querySelector(this.options.el) : this.options.el; let data: Vnode = &#123; tag: &quot;div&quot;, props: &#123; id: 1, key: 1 &#125;, children: [ &#123; tag: &quot;div&quot;, text: &quot;子集1&quot;, &#125;, &#123; tag: &quot;div&quot;, text: &quot;子集2&quot; &#125; ] &#125; app?.appendChild(this.render(data)) console.log(app); this.mount(app as Element) &#125; public mount(app: Element) &#123; document.body.append(app) &#125;&#125; const v = new Vue(&#123; el: &quot;#app&quot;&#125;)","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 7 (内置对象)","slug":"学习TypeScript 7 (内置对象)","date":"2022-02-24T14:24:00.000Z","updated":"2023-04-23T15:42:59.427Z","comments":true,"path":"2022/02/24/学习TypeScript 7 (内置对象)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%207%20(%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1)/","excerpt":"","text":"内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型 ECMAScript 的内置对象 Boolean、Number、string、RegExp、Date、Error 123456789101112let b: Boolean = new Boolean(1)console.log(b)let n: Number = new Number(true)console.log(n)let s: String = new String(&#x27;创建一个string&#x27;)console.log(s)let d: Date = new Date()console.log(d)let r: RegExp = /^1/console.log(r)let e: Error = new Error(&quot;error!&quot;)console.log(e) DOM 和 BOM 的内置对象 Document、HTMLElement、Event、NodeList** 等**​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#x27;div&#x27;);//读取div 这种需要类型断言 或者加个判断应为读不到返回nulllet div:HTMLElement = document.querySelector(&#x27;div&#x27;) as HTMLDivElementdocument.addEventListener(&#x27;click&#x27;, function (e: MouseEvent) &#123; &#125;);//dom元素的映射表interface HTMLElementTagNameMap &#123; &quot;a&quot;: HTMLAnchorElement; &quot;abbr&quot;: HTMLElement; &quot;address&quot;: HTMLElement; &quot;applet&quot;: HTMLAppletElement; &quot;area&quot;: HTMLAreaElement; &quot;article&quot;: HTMLElement; &quot;aside&quot;: HTMLElement; &quot;audio&quot;: HTMLAudioElement; &quot;b&quot;: HTMLElement; &quot;base&quot;: HTMLBaseElement; &quot;bdi&quot;: HTMLElement; &quot;bdo&quot;: HTMLElement; &quot;blockquote&quot;: HTMLQuoteElement; &quot;body&quot;: HTMLBodyElement; &quot;br&quot;: HTMLBRElement; &quot;button&quot;: HTMLButtonElement; &quot;canvas&quot;: HTMLCanvasElement; &quot;caption&quot;: HTMLTableCaptionElement; &quot;cite&quot;: HTMLElement; &quot;code&quot;: HTMLElement; &quot;col&quot;: HTMLTableColElement; &quot;colgroup&quot;: HTMLTableColElement; &quot;data&quot;: HTMLDataElement; &quot;datalist&quot;: HTMLDataListElement; &quot;dd&quot;: HTMLElement; &quot;del&quot;: HTMLModElement; &quot;details&quot;: HTMLDetailsElement; &quot;dfn&quot;: HTMLElement; &quot;dialog&quot;: HTMLDialogElement; &quot;dir&quot;: HTMLDirectoryElement; &quot;div&quot;: HTMLDivElement; &quot;dl&quot;: HTMLDListElement; &quot;dt&quot;: HTMLElement; &quot;em&quot;: HTMLElement; &quot;embed&quot;: HTMLEmbedElement; &quot;fieldset&quot;: HTMLFieldSetElement; &quot;figcaption&quot;: HTMLElement; &quot;figure&quot;: HTMLElement; &quot;font&quot;: HTMLFontElement; &quot;footer&quot;: HTMLElement; &quot;form&quot;: HTMLFormElement; &quot;frame&quot;: HTMLFrameElement; &quot;frameset&quot;: HTMLFrameSetElement; &quot;h1&quot;: HTMLHeadingElement; &quot;h2&quot;: HTMLHeadingElement; &quot;h3&quot;: HTMLHeadingElement; &quot;h4&quot;: HTMLHeadingElement; &quot;h5&quot;: HTMLHeadingElement; &quot;h6&quot;: HTMLHeadingElement; &quot;head&quot;: HTMLHeadElement; &quot;header&quot;: HTMLElement; &quot;hgroup&quot;: HTMLElement; &quot;hr&quot;: HTMLHRElement; &quot;html&quot;: HTMLHtmlElement; &quot;i&quot;: HTMLElement; &quot;iframe&quot;: HTMLIFrameElement; &quot;img&quot;: HTMLImageElement; &quot;input&quot;: HTMLInputElement; &quot;ins&quot;: HTMLModElement; &quot;kbd&quot;: HTMLElement; &quot;label&quot;: HTMLLabelElement; &quot;legend&quot;: HTMLLegendElement; &quot;li&quot;: HTMLLIElement; &quot;link&quot;: HTMLLinkElement; &quot;main&quot;: HTMLElement; &quot;map&quot;: HTMLMapElement; &quot;mark&quot;: HTMLElement; &quot;marquee&quot;: HTMLMarqueeElement; &quot;menu&quot;: HTMLMenuElement; &quot;meta&quot;: HTMLMetaElement; &quot;meter&quot;: HTMLMeterElement; &quot;nav&quot;: HTMLElement; &quot;noscript&quot;: HTMLElement; &quot;object&quot;: HTMLObjectElement; &quot;ol&quot;: HTMLOListElement; &quot;optgroup&quot;: HTMLOptGroupElement; &quot;option&quot;: HTMLOptionElement; &quot;output&quot;: HTMLOutputElement; &quot;p&quot;: HTMLParagraphElement; &quot;param&quot;: HTMLParamElement; &quot;picture&quot;: HTMLPictureElement; &quot;pre&quot;: HTMLPreElement; &quot;progress&quot;: HTMLProgressElement; &quot;q&quot;: HTMLQuoteElement; &quot;rp&quot;: HTMLElement; &quot;rt&quot;: HTMLElement; &quot;ruby&quot;: HTMLElement; &quot;s&quot;: HTMLElement; &quot;samp&quot;: HTMLElement; &quot;script&quot;: HTMLScriptElement; &quot;section&quot;: HTMLElement; &quot;select&quot;: HTMLSelectElement; &quot;slot&quot;: HTMLSlotElement; &quot;small&quot;: HTMLElement; &quot;source&quot;: HTMLSourceElement; &quot;span&quot;: HTMLSpanElement; &quot;strong&quot;: HTMLElement; &quot;style&quot;: HTMLStyleElement; &quot;sub&quot;: HTMLElement; &quot;summary&quot;: HTMLElement; &quot;sup&quot;: HTMLElement; &quot;table&quot;: HTMLTableElement; &quot;tbody&quot;: HTMLTableSectionElement; &quot;td&quot;: HTMLTableDataCellElement; &quot;template&quot;: HTMLTemplateElement; &quot;textarea&quot;: HTMLTextAreaElement; &quot;tfoot&quot;: HTMLTableSectionElement; &quot;th&quot;: HTMLTableHeaderCellElement; &quot;thead&quot;: HTMLTableSectionElement; &quot;time&quot;: HTMLTimeElement; &quot;title&quot;: HTMLTitleElement; &quot;tr&quot;: HTMLTableRowElement; &quot;track&quot;: HTMLTrackElement; &quot;u&quot;: HTMLElement; &quot;ul&quot;: HTMLUListElement; &quot;var&quot;: HTMLElement; &quot;video&quot;: HTMLVideoElement; &quot;wbr&quot;: HTMLElement;&#125; 定义Promise 如果我们在编程中不指定返回的类型，TypeScript是无法推断返回的类型的： 指定了返回类型： 函数定义返回promise 语法规则: Promise&lt;T&gt; 类型&amp;#x20; 123456789function promise(): Promise&lt;number&gt; &#123; return new Promise&lt;number&gt;((resolve, reject)) =&gt; &#123; resolve(1) &#125;&#125;promise().then(res =&gt; &#123; console.log(res)&#125;) 当我们在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了；而他们的定义文件，则在 TypeScript 核心库的定义文件中 示例： 1234567891011121314151617181920let canvas = document.querySelector(&#x27;#canvas&#x27;) as HTMLCanvasElementlet ctx = canvas.getContext(&#x27;2d&#x27;) as CanvasRenderingContext2Dcanvas.height = screen.availHeight; //可视区域的高度canvas.width = screen.availWidth; //可视区域的宽度let str: string[] = &#x27;XMZSWSSBXMZSWSSBXMZSWSSBXMZSWSSBXMZSWSSB&#x27;.split(&#x27;&#x27;)let Arr = Array(Math.ceil(canvas.width / 10)).fill(0) //获取宽度例如1920 / 10 192console.log(Arr); const rain = () =&gt; &#123; ctx.fillStyle = &#x27;rgba(0,0,0,0.05)&#x27;//填充背景颜色 ctx.fillRect(0, 0, canvas.width, canvas.height)//背景 ctx.fillStyle = &quot;#0f0&quot;; //文字颜色 Arr.forEach((item, index) =&gt; &#123; ctx.fillText(str[ Math.floor(Math.random() * str.length) ], index * 10, item + 10) Arr[index] = item &gt;= canvas.height || item &gt; 10000 * Math.random() ? 0 : item + 10; //添加随机数让字符随机出现不至于那么平整 &#125;) console.log(Arr); &#125;setInterval(rain, 40)","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 6 (类型断言 - 联合类型 - 交叉类型)","slug":"学习TypeScript 6 (类型断言 - 联合类型 - 交叉类型)","date":"2022-02-24T13:05:00.000Z","updated":"2023-04-23T11:25:10.969Z","comments":true,"path":"2022/02/24/学习TypeScript 6 (类型断言 - 联合类型 - 交叉类型)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%206%20(%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%20-%20%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%20-%20%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B)/","excerpt":"","text":"类型断言 | 联合类型 | 交叉类型联合类型123456// 例如我们的手机号通常是 13XXXXXXX 为数字类型 这时候产品说需要支持座机// 所以我们就可以使用联合类型支持座机字符串let myPhone: number | string = &#x27;010-820&#x27;// 这样写是会报错，因为我们的联合类型只有数字和字符串并没有布尔值let myPhone: number | string = true 函数使用联合类型：123const fn = (something:number | boolean):boolean =&gt; &#123; return !!something&#125; 交叉类型 多种类型的集合，联合对象将具有所有类型的所有成员12345678910111213141516interface People &#123; age: number, height： number&#125;interface Man&#123; sex: string&#125;const peopleObj = (man: People &amp; Man) =&gt; &#123; console.log(man.age) console.log(man.height) console.log(man.sex)&#125;peopleObj(&#123;age: 18,height: 180,sex: &#x27;male&#x27;&#125;) 类型断言 语法： 值 as 类型； 或 &lt;类型&gt;值 value as string &lt;string&gt;value 123456789101112interface A &#123; run: string&#125; interface B &#123; build: string&#125; const fn = (type: A | B): string =&gt; &#123; return type.run&#125;// 这样写是有警告的应为B的接口上面是没有定义run这个属性的 123456789101112interface A &#123; run: string&#125; interface B &#123; build: string&#125; const fn = (type: A | B): string =&gt; &#123; return (type as A).run&#125;// 可以使用类型断言来推断他传入的是A接口的值 📌需要注意的是：类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误： 12window.abc = 123//这样写会报错因为window没有abc这个东西 12(window as any).abc = 123// 可以使用 any 临时断言在 any 类型的变量上，访问任何属性都是允许的。 as const 是对字面量的断言，与const直接定义常量是有区别的 如果是普通类型跟直接const声明是一样的12345const names = &#x27;wesson&#x27;names = &#x27;aa&#x27; // 无法修改let names2 = &#x27;wesson&#x27; as constnames2 = &#x27;aa&#x27; // 无法修改 123456// 数组let a1 = [ 10, 20 ] as constconst a2 = [ 10, 20 ] a1.unshift(30); // 错误，此时已经断言字面量为[10, 20],数据无法做任何修改a2.unshift(30); // 通过，没有修改指针 类型断言是不具影响力的 在下面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用 并不会影响结果, 因为编译过程中会删除类型断言123456function toBoolean(something: any): boolean &#123; return something as boolean;&#125;toBoolean(1);// 返回值为 1","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 5 (函数扩展)","slug":"学习TypeScript 5 (函数扩展)","date":"2022-02-24T12:22:00.000Z","updated":"2023-04-23T11:24:29.608Z","comments":true,"path":"2022/02/24/学习TypeScript 5 (函数扩展)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%205%20(%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95)/","excerpt":"","text":"函数扩展函数的类型12345// 注意，参数不能多传，也不能少传 必须按照约定的类型来const fn = (name: string, age:number): string =&gt; &#123; return name + age&#125;fn(&#x27;张三&#x27;,18) 函数的可选参数?12345// 通过 ? 表示该参数为可选参数const fn = (name: string, age?:number): string =&gt; &#123; return name + age&#125;fn(&#x27;张三&#x27;) 函数参数的默认值1234const fn = (name: string = &quot;我是默认值&quot;): string =&gt; &#123; return name&#125;fn() 接口定义函数123456789101112131415161718// 定义参数 num 和 num2 ：后面定义返回值的类型interface Add &#123; (num: number, num2: number): number&#125; const fn: Add = (num: number, num2: number): number =&gt; &#123; return num + num2&#125;fn(5, 5) interface User&#123; name: string; age: number;&#125;function getUserInfo(user: User): User &#123; return user&#125; 定义剩余参数12345678const fn = (array:number[],...items:any[]):any[] =&gt; &#123; console.log(array,items) return items&#125; let a:number[] = [1,2,3] fn(a,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;) 函数重载 重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。 如果参数类型不同，则参数类型应设置为 any。 参数数量不同你可以将不同的参数设置为可选。123456789101112function fn(params: number): void function fn(params: string, params2: number): void function fn(params: any, params2?: any): void &#123; console.log(params) console.log(params2)&#125;fn(123) fn(&#x27;123&#x27;,456)","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 4 (数组类型)","slug":"学习TypeScript 4 (数组类型)","date":"2022-02-24T11:49:00.000Z","updated":"2023-04-23T10:55:53.163Z","comments":true,"path":"2022/02/24/学习TypeScript 4 (数组类型)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%204%20(%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B)/","excerpt":"","text":"数组类型数组的类型 类型[]123456789101112// 类型加中括号let arr: number[] = [ 123 ]// 这样会报错定义了数字类型出现字符串是不允许的let arr:number[] = [ 1, 2, 3, &#x27;1&#x27; ]// 操作方法添加也是不允许的let arr:number[] = [ 1, 2, 3 ]// 编辑器报错arr.unshift(&#x27;1&#x27;) var arr: number[] = [1, 2, 3]; // 数字类型的数组var arr2: string[] = [&quot;1&quot;, &quot;2&quot;]; // 字符串类型的数组var arr3: any[] = [1, &quot;2&quot;, true]; // 任意类型的数组 数组泛型 规则： Array&lt;类型&gt;1let arr:Array&lt;number&gt; = [ 1, 2, 3, 4, 5 ] 用接口表示数组 一般用来描述类数组12345interface NumberArray &#123; [index: number]: number&#125;// 表示只要索引的类型是数字时，那么值的类型必须是数字。let fibonacci: NumberArray = [ 1, 2, 2, 4, 3 ] 多维数组1let data:number[][] = [[ 1, 2 ], [ 3, 4 ]] arguments类数组123456789101112131415161718192021function Arr(...args:any): void &#123; console.log(arguments) // 错误的arguments 是类数组不能这样定义 let arr:number[] = arguments&#125;Arr(111, 222, 333)function Arr(...args:any): void &#123; console.log(arguments) // ts内置对象IArguments 定义 let arr:IArguments = arguments&#125;Arr(111, 222, 333) // 其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：interface IArguments &#123; [index: number]: any; length: number; callee: Function;&#125; any 在数组中的应用 一个常见的例子数组中可以存在任意类型1let list: any[] = [&#x27;test&#x27;, 1, [],&#123; a: 1 &#125;]","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 3 (接口和对象类型)","slug":"学习TypeScript 3 (接口和对象类型)","date":"2022-02-24T07:19:00.000Z","updated":"2023-04-23T10:55:09.137Z","comments":true,"path":"2022/02/24/学习TypeScript 3 (接口和对象类型)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%203%20(%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B)/","excerpt":"","text":"接口和对象类型对象的类型 在typescript中，我们定义对象的方式要用关键字interface（接口），我的理解是使用interface来定义一种约束，让数据的结构满足约束的格式。定义方式如下：12345678910111213/* * 这样写是会报错的 因为我们在person定义了a，b但是对象里面缺少b属性 * 使用接口约束的时候不能多一个属性也不能少一个属性 * 必须与接口保持一致 */interface Person &#123; b:string, a:string&#125; const person:Person = &#123; a:&quot;213&quot;&#125; 12345678910111213141516171819202122232425// 重名 interface 可以合并interface A &#123; name: string&#125;interface A &#123; age: number&#125;var x:A = &#123; name:&#x27;xx&#x27;, age:20&#125;// 继承interface A&#123; name:string&#125; interface B extends A&#123; age:number&#125; let obj:B = &#123; age:18, name:&quot;string&quot;&#125; 可选属性 使用?操作符12345678910// 可选属性的含义是该属性可以不存在// 所以说这样写也是没问题的interface Person &#123; b?: string, a: string&#125; const person:Person = &#123; a: &quot;213&quot;&#125; 任意属性 [propName: string] 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集12345678910111213// 在这个例子当中我们看到接口中并没有定义C但是并没有报错// 因为我们定义了[propName: string]: any;// 允许添加新的任意属性interface Person &#123; b?:string, a:string, [propName: string]: any;&#125; const person:Person = &#123; a:&quot;213&quot;, c:&quot;123&quot;&#125; 只读属性 readonly readonly 只读属性是不允许被赋值的只能读取1234567891011121314// 这样写是会报错的// 应为a是只读的不允许重新赋值interface Person &#123; b?: string, readonly a: string, [propName: string]: any;&#125;const person: Person = &#123; a: &quot;213&quot;, c: &quot;123&quot;&#125;person.a = 123 添加函数1234567891011121314interface Person &#123; b?: string, readonly a: string, [propName: string]: any; cb:()=&gt;void&#125; const person: Person = &#123; a: &quot;213&quot;, c: &quot;123&quot;, cb:()=&gt;&#123; console.log(123) &#125;&#125;","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 2 (任意类型)","slug":"学习TypeScript 2 (任意类型)","date":"2022-02-24T06:23:00.000Z","updated":"2023-04-23T10:36:20.760Z","comments":true,"path":"2022/02/24/学习TypeScript 2 (任意类型)/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%202%20(%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B)/","excerpt":"","text":"任意类型Any 类型 和 unknown 顶级类型 开始前推荐安装下node的插件：123npm i @type/node --save-devn# node环境支持的依赖npm i ts-node --g 没有强制限定哪种类型，随时切换类型都可以 我们可以对 any 进行任何操作，不需要检查类型123let anys: any = 123anys = &#x27;123&#x27;anys = true 声明变量的时候没有指定任意类型默认为any1234let anys;anys = &#x27;123&#x27;anys = true 如果使用any就失去了TypeScript类型检测的作用 TypeScript 3.0 引入了 unknown 类型，也被认为是top type，但它更安全；与any一样，所有类型都可以分配给 unknown unknow类型比any更加严格当你要使用any 的时候可以尝试使用unknow123456789101112131415161718192021222324252627// unknown 可以定义任何类型的值let value: unknown; value = true; // OKvalue = 42; // OKvalue = &quot;Hello World&quot;; // OKvalue = []; // OKvalue = &#123;&#125;; // OKvalue = null; // OKvalue = undefined; // OKvalue = Symbol(&quot;type&quot;); // OK // 这样写会报错 unknow 类型不能作为子类型只能作为父类型// any 可以作为父类型和子类型// unknown 类型不能赋值给其他类型let names:unknown = &#x27;123&#x27;let names2:string = names // 这样就没问题 any 类型是可以的let names:any = &#x27;123&#x27;let names2:string = names // unknown 可赋值对象只有unknown 和 anylet bbb:unknown = &#x27;123&#x27;let aaa:any= &#x27;456&#x27;aaa = bbb 区别212345678// 如果是 any 类型在对象没有这个属性的时候还在获取是不会报错的let obj: any = &#123;b:1&#125;obj.a// 如果是unknow 是不能调用属性和方法let obj: unknown = &#123; b:1, ccc:(): number=&gt;213 &#125;obj.bobj.ccc()","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"学习TypeScript 1 (基础类型)","slug":"学习TypeScript 1（基础类型）","date":"2022-02-24T04:41:00.000Z","updated":"2023-04-23T10:35:32.998Z","comments":true,"path":"2022/02/24/学习TypeScript 1（基础类型）/","link":"","permalink":"http://example.com/2022/02/24/%E5%AD%A6%E4%B9%A0TypeScript%201%EF%BC%88%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%EF%BC%89/","excerpt":"","text":"基础类型TypeScript是JavaScript的超集，所以JavaScript的类型都包含在内 起步 全局安装TypeScript 1# npm install typescript -g 在终端运行tsc 文件名 基础类型：Boolean、Number、String、null、undefined 以及 ES6 的 Symbol 和 ES10 的 BigInt。 字符串类型 字符串是使用String定义的，如： 1234let a:string = &#x27;123&#x27;// 普通声明let str: string = `abc$&#123;d&#125;`// 也可使用es6的模板字符串 其中 ` 用来定义 ES6 中的模板字符串，$&#123;expr&#125; 用来在模板字符串中嵌入表达式。 数字类型 支持十六进制、十进制、八进制和二进制 1234567let notANumber: number = NaN; // Nanlet num: number = 123; // 普通数字let infinityNumber: number = Infinity; // 无穷大let decimal: number = 10; // 十进制let hex: number = 0xf00d; // 十六进制let binary: number = 0b1010; // 二进制let octal: number = 0o744; // 八进制 3.布尔类型 注意，使用构造函数 Boolean 创造的对象不是布尔值： 123let createdBoolean: boolean = new Boolean(1)//这样会报错 应为事实上 new Boolean() 返回的是一个 Boolean 对象 事实上new Boolean()返回的是一个Boolean对象，需要改为： 1let createdBoolean: Boolean = new Boolean(1) 123let booleand: boolean = true // 可以直接使用布尔值 let booleand2: boolean = Boolean(1) // 也可以通过函数返回布尔值 空值类型 JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数 123function voidFn(): void &#123; console.log(&#x27;This is a function with no return value&#x27;)&#125; void 类型的用法，主要是用在我们不希望调用者关心函数返回值的情况下，比如通常的异步回调函数 void也可以定义undefined 和 null 类型 12let u: void = undefinedlet n: void = null Null和undefined类型12let u: void = undefined // 定义 undefinedlet n: void = null // 定义 null void 和 undefined 和 null 最大的区别 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 string 类型的变量： 12345// 这样写会报错 void类型不可以分给其他类型let test: void = undefinedlet num2: string = &quot;1&quot;num2 = test 需改为： 1234567891011//这样是没问题的let test: null = nulllet num2: string = &quot;1&quot; num2 = test //或者这样的let test: undefined = undefinedlet num2: string = &quot;1&quot; num2 = test 📌注意：如果你配置了 tsconfig.json 开启严格模式 123&#123; &quot;compilerOptions&quot;:&#123; &quot;strict&quot;: true &#125;&#125; null 不能 赋予 void 类型","categories":[{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"学习TypeScript","slug":"学习TypeScript","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Vite","slug":"Vite","permalink":"http://example.com/tags/Vite/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]}